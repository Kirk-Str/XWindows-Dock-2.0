#include "intercept.h"

WORD OPCODES1[256] =
{
	0x4211, 0x42E4, 0x2011, 0x20E4, 0x8401, 0x8C42, 0x0000, 0x0000, 0x4211, 0x42E4,
	0x2011, 0x20E4, 0x8401, 0x8C42, 0x0000, 0x0000, 0x4211, 0x42E4, 0x2011, 0x20E4,
	0x8401, 0x8C42, 0x0000, 0x0000, 0x4211, 0x42E4, 0x2011, 0x20E4, 0x8401, 0x8C42,
	0x0000, 0x0000, 0x4211, 0x42E4, 0x2011, 0x20E4, 0x8401, 0x8C42, 0x0000, 0x8000,
	0x4211, 0x42E4, 0x2011, 0x20E4, 0x8401, 0x8C42, 0x0000, 0x8000, 0x4211, 0x42E4,
	0x2011, 0x20E4, 0x8401, 0x8C42, 0x0000, 0x8000, 0x0211, 0x02E4, 0x0011, 0x00E4,
	0x0401, 0x0C42, 0x0000, 0x8000, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045,
	0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045,
	0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x6045, 0x6045,
	0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x6045, 0x0000, 0x8000, 0x00E4, 0x421A,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0C00, 0x2CE4, 0x0400, 0x24E4, 0x0000, 0x0000,
	0x0000, 0x0000, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400,
	0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x1400, 0x0510, 0x0DA0,
	0x0510, 0x05A0, 0x0211, 0x02E4, 0xA211, 0xA2E4, 0x4211, 0x42E4, 0x2011, 0x20E4,
	0x42E3, 0x20E4, 0x00E3, 0x01A0, 0x0000, 0xE046, 0xE046, 0xE046, 0xE046, 0xE046,
	0xE046, 0xE046, 0x8000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8000,
	0x8101, 0x8142, 0x0301, 0x0342, 0x0000, 0x0000, 0x0000, 0x0000, 0x0401, 0x0C42,
	0x0000, 0x0000, 0x8000, 0x8000, 0x0000, 0x0000, 0x6404, 0x6404, 0x6404, 0x6404,
	0x6404, 0x6404, 0x6404, 0x6404, 0x6C45, 0x6C45, 0x6C45, 0x6C45, 0x6C45, 0x6C45,
	0x6C45, 0x6C45, 0x4510, 0x45A0, 0x0800, 0x0000, 0x20E4, 0x20E4, 0x4510, 0x4DA0,
	0x0000, 0x0000, 0x0800, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x4110, 0x41A0,
	0x4110, 0x41A0, 0x8400, 0x8400, 0x0000, 0x8000, 0x0008, 0x0008, 0x0008, 0x0008,
	0x0008, 0x0008, 0x0008, 0x0008, 0x1400, 0x1400, 0x1400, 0x1400, 0x8401, 0x8442,
	0x0601, 0x0642, 0x1C00, 0x1C00, 0x0000, 0x1400, 0x8007, 0x8047, 0x0207, 0x0247,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0008, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x4110, 0x01A0
};

WORD OPCODES2[256] = 
{
	0x0118, 0x0120, 0x20E4, 0x20E4, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0xFFFF, 0xFFFF, 0xFFFF, 0x0110, 0x0000, 0x052D, 0x003F, 0x023F, 0x003F, 0x023F,
    0x003F, 0x003F, 0x003F, 0x023F, 0x0110, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0x4023, 0x4023, 0x0223, 0x0223, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x003F, 0x023F, 0x002F, 0x023F, 0x003D, 0x003D, 0x003F, 0x003F, 0x0000, 0x8000,
	0x8000, 0x8000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4,
	0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4, 0x20E4,
	0x4227, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
	0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0x0065, 0x00ED, 0x04ED, 0x04A8, 0x04A8, 0x04A8, 0x00ED, 0x00ED, 0x00ED, 0x0000,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0265, 0x02ED, 0x1C00, 0x1C00,
	0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x1C00,
	0x1C00, 0x1C00, 0x1C00, 0x1C00, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110,
	0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110, 0x4110,
	0x0000, 0x0000, 0x8000, 0x02E4, 0x47E4, 0x43E4, 0xC211, 0xC2E4, 0x0000, 0x0000,
	0x0000, 0x42E4, 0x47E4, 0x43E4, 0x0020, 0x20E4, 0xC211, 0xC2E4, 0x20E4, 0x42E4,
	0x20E4, 0x22E4, 0x2154, 0x211C, 0xFFFF, 0xFFFF, 0x05A0, 0x42E4, 0x20E4, 0x20E4,
	0x2154, 0x211C, 0xA211, 0xA2E4, 0x043F, 0x0224, 0x0465, 0x24AC, 0x043F, 0x8128,
	0x6005, 0x6005, 0x6005, 0x6005, 0x6005, 0x6005, 0x6005, 0x6005, 0xFFFF, 0x00ED,
	0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x02ED, 0x20AC, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0x003F, 0x02ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0xFFFF, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED,
	0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x00ED, 0x0000         
};

WORD OPCODES3[10][16] =
{
	(0x0510, 0xFFFF, 0x4110, 0x4110, 0x8110, 0x8110, 0x8110, 0x8110, 0x0510, 0xFFFF,
	0x4110, 0x4110, 0x8110, 0x8110, 0x8110, 0x8110),
	(0x0DA0, 0xFFFF, 0x41A0, 0x41A0, 0x81A0, 0x81A0, 0x81A0, 0x81A0, 0x0DA0, 0xFFFF,
	0x41A0, 0x41A0, 0x81A0, 0x81A0, 0x81A0, 0x81A0),
	(0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0036, 0x0036,
	0x0030, 0x0030, 0x0036, 0x0036, 0x0036, 0x0036),
	(0x0120, 0xFFFF, 0x0120, 0x0120, 0x0110, 0x0118, 0x0110, 0x0118, 0x0030, 0x0030,
	0x0000, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000),
	(0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0120, 0x0036, 0x0036,
	0x0036, 0x0036, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF),
	(0x0120, 0xFFFF, 0x0120, 0x0120, 0xFFFF, 0x0130, 0xFFFF, 0x0130, 0x0036, 0x0036,
	0x0036, 0x0036, 0x0000, 0x0036, 0x0036, 0x0000),
	(0x0128, 0x0128, 0x0128, 0x0128, 0x0128, 0x0128, 0x0128, 0x0128, 0x0236, 0x0236,
	0x0030, 0x0030, 0x0236, 0x0236, 0x0236, 0x0236),
	(0x0128, 0xFFFF, 0x0128, 0x0128, 0x0110, 0xFFFF, 0x0110, 0x0118, 0x0030, 0x0030,
	0x0030, 0x0030, 0x0030, 0x0030, 0xFFFF, 0xFFFF),
	(0x0118, 0x0118, 0x0118, 0x0118, 0x0118, 0x0118, 0x0118, 0x0118, 0x0236, 0x0236,
	0x0030, 0x0236, 0x0236, 0x0236, 0x0236, 0x0236),
	(0x0118, 0xFFFF, 0x0118, 0x0118, 0x0130, 0x0128, 0x0130, 0x0128, 0x0030, 0x0030,
	0x0030, 0x0030, 0x0000, 0x0036, 0x0036, 0xFFFF)
};

DWORD SizeOfCode(void *code)
{
	DWORD last = (DWORD)code;
	bool addrOveride = false, fixed = false;
	DWORD operandOveride = 4, extend = 0, size;
	WORD flags, opcode, rm, modrm;
	if(last)
	{
		do
		{
			opcode = (*((BYTE*)code));
			code = (void*)((DWORD)code + 1);
			if(opcode == 0x66)
			{
				operandOveride = 2;
			}
			else
			if(opcode == 0x67)
			{
				addrOveride = true;
			}
			else
			if(((opcode & 0xe7) != 0x26) && (opcode < 0x64) || (opcode > 0x65))
			{
				fixed = true;
			}
		}
		while(!fixed);
		if(opcode == 0x0f)
		{
			opcode = (*((BYTE*)code));
			flags = OPCODES2[opcode];
			opcode += 0x0f00;
			code = (void*)((DWORD)code + 1);
		}
		else
		{
			flags = OPCODES1[opcode];
		}
		if(flags & 0x0038)
		{
			modrm = (*((BYTE*)code));
			rm = modrm & 0x7;
			code = (void*)((DWORD)code + 1);
			size = 0;
			switch(modrm & 0xc0)
			{
			case 0x40:
				{
					size = 1;
				}
				break;

			case 0x80:
				{
					size = addrOveride ? 2 : 4;
				}
				break;
			}
			if(!(((modrm & 0xc0) != 0xc0) && addrOveride))
			{
				if((rm == 4) && ((modrm & 0xc0) != 0xc0))
				{
					rm = (*((BYTE*)code)) & 0x7;
				}
				if(((modrm & 0xc0) == 0) && (rm == 5))
				{
					size = 4;
				}
				code = (void*)((DWORD)code + size);
			}
			if((flags & 0x0038) == 0x0008)
			{
				switch(opcode)
				{
				case 0xf6:
					extend = 0;
					break;

				case 0xf7: 
					extend = 1;
					break;

				case 0xd8: 
					extend = 2;
					break;

				case 0xd9: 
					extend = 3;
					break;

				case 0xda: 
					extend = 4;
					break;

				case 0xdb: 
					extend = 5;
					break;

				case 0xdc: 
					extend = 6;
					break;

				case 0xdd: 
					extend = 7;
					break;

				case 0xde: 
					extend = 8;
					break;

				case 0xdf: 
					extend = 9;
					break;
				}
				if((modrm & 0xc0) != 0xc0)
				{
					flags = OPCODES3[extend][(modrm >> 3) & 0x7];
				}
				else
				{
					flags = OPCODES3[extend][((modrm >> 3) & 0x7) + 8];
				}
			}
		}
		switch(flags & 0x0c00)
		{
		case 0x0400:
			code = (void*)((DWORD)code + 1);
			break;

		case 0x0800:
			code = (void*)((DWORD)code + 2);
			break;

		case 0x0c00:
			code = (void*)((DWORD)code + operandOveride);
			break;

		default:
			{
				switch(opcode)
				{
				case 0x9a:
				case 0xea:
					code = (void*)((DWORD)code + operandOveride + 2);
					break;

				case 0xc8:
					code = (void*)((DWORD)code + 3);
					break;

				case 0xa0:
				case 0xa1:
				case 0xa2:
				case 0xa3:
					code = (void*)((DWORD)code + addrOveride ? 2 : 4);
					break;
				}
			}
			break;
		}
	}
	return (DWORD)code - last;
}

DWORD InterceptAPISaveFunction(void *functionAddr, void *functionOldAddr)
{
	DWORD saveSize = 0;
	void *next = functionAddr;
	while(saveSize < 5)
	{
		DWORD size = SizeOfCode(next);
		next = (void*)((DWORD)next + size);
		saveSize += size;
	}
	memcpy(functionOldAddr, functionAddr, saveSize);

	//7 bytes
	//(*((BYTE*)((DWORD)functionOldAddr + saveSize))) = 0xb8; // mov eax,
	//(*((DWORD*)((DWORD)functionOldAddr + saveSize + 1))) = (DWORD)next; // absolute address
	//(*((WORD*)((DWORD)functionOldAddr + saveSize + 5))) = 0xE0FF; // jmp eax

	// 5 bytes
	(*((BYTE*)((DWORD)functionOldAddr + saveSize))) = 0xe9; // jmp
	(*((DWORD*)((DWORD)functionOldAddr + saveSize + 1))) = (DWORD)next - (DWORD)functionOldAddr - 5 - saveSize; // relative address

	return saveSize;
}

bool InterceptAPI(wchar_t *module, char *functionName, void *functionInterceptAddr, void **functionOldAddr)
{
	void *functionAddr = GetProcAddress(GetModuleHandle(module), functionName);
	if(!functionAddr)
	{
		return false;
	}
	DWORD oldProtect;
	VirtualProtect(functionAddr, 5, PAGE_EXECUTE_READWRITE, &oldProtect);

	void *oldFunction = VirtualAlloc(NULL, 255, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	(*(DWORD*)oldFunction) = (DWORD)functionAddr;
	(*((BYTE*)((DWORD)oldFunction + 4))) = (BYTE)InterceptAPISaveFunction(functionAddr, (void*)((DWORD)oldFunction + 5));

	(*((BYTE*)functionAddr)) = 0xe9;
	(*((DWORD*)((DWORD)functionAddr + 1))) = (DWORD)functionInterceptAddr - (DWORD)functionAddr - 5;

	VirtualProtect(functionAddr, 5, oldProtect, &oldProtect);

	(*functionOldAddr) = (void*)((DWORD)oldFunction + 5);
	return true;
}

bool InterceptAPIRestore(void *functionOldAddr)
{
	void *proc = (void*)(*((DWORD*)((DWORD)functionOldAddr - 5)));
	DWORD saveSize = (*((BYTE*)((DWORD)functionOldAddr - 1)));
	DWORD oldProtect;
	VirtualProtect(proc, 5, PAGE_EXECUTE_READWRITE, &oldProtect);
	memcpy(proc, functionOldAddr, saveSize);
	VirtualProtect(proc, 5, oldProtect, &oldProtect);
	VirtualFree((void*)((DWORD)functionOldAddr - 5), 255, MEM_RELEASE);
	return true;
}

bool ThreadsState(bool suspend)
{
	HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
	if(h == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	DWORD curThreadId = GetCurrentThreadId();
	DWORD curProcessId = GetCurrentProcessId();

	THREADENTRY32 thread = {0};
	thread.dwSize = sizeof(THREADENTRY32);
	if(Thread32First(h, &thread))
	do
	{
		if((thread.th32OwnerProcessID == curProcessId) && (thread.th32ThreadID != curThreadId))
		{
			HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, thread.th32ThreadID);
			if(hThread)
			{
				if(suspend)
				{
					SuspendThread(hThread);
				}
				else
				{
					ResumeThread(hThread);
				}
				CloseHandle(hThread);
			}
		}
	}
	while(Thread32Next(h, &thread));

	CloseHandle(h);
	return true;
}